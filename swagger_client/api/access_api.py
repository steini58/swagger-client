# coding: utf-8

"""
    

    [AHOI cookbook](/ahoi/docs/cookbook/index.html)  [Data Privacy](/sandboxmanager/#/privacy)  [Terms of Service](/sandboxmanager/#/terms)  [Imprint](https://sparkassen-hub.com/impressum/)  &copy; 2016&dash;2017 Starfinanz - Ein Unternehmen der Finanz Informatik  # noqa: E501

    OpenAPI spec version: 2.1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class AccessApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def delete_access(self, access_id, **kwargs):  # noqa: E501
        """Delete access  # noqa: E501

        Delete access with **accessId** and all related accounts. This also deletes related notifications. If this is a user's last remaining access, all notification targets will also be deleted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_access(access_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str access_id: The **id** for the access to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_access_with_http_info(access_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_access_with_http_info(access_id, **kwargs)  # noqa: E501
            return data

    def delete_access_with_http_info(self, access_id, **kwargs):  # noqa: E501
        """Delete access  # noqa: E501

        Delete access with **accessId** and all related accounts. This also deletes related notifications. If this is a user's last remaining access, all notification targets will also be deleted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_access_with_http_info(access_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str access_id: The **id** for the access to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['access_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_access" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'access_id' is set
        if ('access_id' not in params or
                params['access_id'] is None):
            raise ValueError("Missing the required parameter `access_id` when calling `delete_access`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'access_id' in params:
            path_params['accessId'] = params['access_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/accesses/{accessId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_access(self, access_id, **kwargs):  # noqa: E501
        """Get access  # noqa: E501

        Retrieve the access with **accessId**. The retrieved object does not contain sensitive information such as the PIN.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_access(access_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str access_id: The **id** for the access to retrieve. (required)
        :return: Access
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_access_with_http_info(access_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_access_with_http_info(access_id, **kwargs)  # noqa: E501
            return data

    def get_access_with_http_info(self, access_id, **kwargs):  # noqa: E501
        """Get access  # noqa: E501

        Retrieve the access with **accessId**. The retrieved object does not contain sensitive information such as the PIN.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_access_with_http_info(access_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str access_id: The **id** for the access to retrieve. (required)
        :return: Access
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['access_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_access" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'access_id' is set
        if ('access_id' not in params or
                params['access_id'] is None):
            raise ValueError("Missing the required parameter `access_id` when calling `get_access`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'access_id' in params:
            path_params['accessId'] = params['access_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/accesses/{accessId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Access',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_accesses(self, **kwargs):  # noqa: E501
        """List accesses  # noqa: E501

        Returns all registered accesses for the authenticated user. Confidential information like the PIN will not be returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_accesses(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[Access]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_accesses_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_accesses_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_accesses_with_http_info(self, **kwargs):  # noqa: E501
        """List accesses  # noqa: E501

        Returns all registered accesses for the authenticated user. Confidential information like the PIN will not be returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_accesses_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[Access]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_accesses" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/accesses', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Access]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_asset(self, access_id, account_id, asset_id, **kwargs):  # noqa: E501
        """Get transaction.  # noqa: E501

        Returns the asset identified by **assetId** in relationship with  **accountId**.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_asset(access_id, account_id, asset_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str access_id: (required)
        :param str account_id: The **id** for the account. (required)
        :param str asset_id: The **assetId** for the asset to retrieve (required)
        :return: Asset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_asset_with_http_info(access_id, account_id, asset_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_asset_with_http_info(access_id, account_id, asset_id, **kwargs)  # noqa: E501
            return data

    def get_asset_with_http_info(self, access_id, account_id, asset_id, **kwargs):  # noqa: E501
        """Get transaction.  # noqa: E501

        Returns the asset identified by **assetId** in relationship with  **accountId**.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_asset_with_http_info(access_id, account_id, asset_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str access_id: (required)
        :param str account_id: The **id** for the account. (required)
        :param str asset_id: The **assetId** for the asset to retrieve (required)
        :return: Asset
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['access_id', 'account_id', 'asset_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_asset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'access_id' is set
        if ('access_id' not in params or
                params['access_id'] is None):
            raise ValueError("Missing the required parameter `access_id` when calling `get_asset`")  # noqa: E501
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `get_asset`")  # noqa: E501
        # verify the required parameter 'asset_id' is set
        if ('asset_id' not in params or
                params['asset_id'] is None):
            raise ValueError("Missing the required parameter `asset_id` when calling `get_asset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'access_id' in params:
            path_params['accessId'] = params['access_id']  # noqa: E501
        if 'account_id' in params:
            path_params['accountId'] = params['account_id']  # noqa: E501
        if 'asset_id' in params:
            path_params['assetId'] = params['asset_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/accesses/{accessId}/accounts/{accountId}/assets/{assetId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Asset',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_assets(self, access_id, account_id, **kwargs):  # noqa: E501
        """Returns a list of assets for the related account represented by path  parameter accountId.  # noqa: E501

        The return list can be filtered by the query  parameters \"max-age\".  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_assets(access_id, account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str access_id: (required)
        :param str account_id: The **id** for the account. (required)
        :param int max_age: optional - in seconds - indicates the maximum acceptable         timeframe since the last refresh of the given account
        :return: list[Asset]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_assets_with_http_info(access_id, account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_assets_with_http_info(access_id, account_id, **kwargs)  # noqa: E501
            return data

    def list_assets_with_http_info(self, access_id, account_id, **kwargs):  # noqa: E501
        """Returns a list of assets for the related account represented by path  parameter accountId.  # noqa: E501

        The return list can be filtered by the query  parameters \"max-age\".  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_assets_with_http_info(access_id, account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str access_id: (required)
        :param str account_id: The **id** for the account. (required)
        :param int max_age: optional - in seconds - indicates the maximum acceptable         timeframe since the last refresh of the given account
        :return: list[Asset]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['access_id', 'account_id', 'max_age']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_assets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'access_id' is set
        if ('access_id' not in params or
                params['access_id'] is None):
            raise ValueError("Missing the required parameter `access_id` when calling `list_assets`")  # noqa: E501
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `list_assets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'access_id' in params:
            path_params['accessId'] = params['access_id']  # noqa: E501
        if 'account_id' in params:
            path_params['accountId'] = params['account_id']  # noqa: E501

        query_params = []
        if 'max_age' in params:
            query_params.append(('max-age', params['max_age']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/accesses/{accessId}/accounts/{accountId}/assets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Asset]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_access(self, access_dto, **kwargs):  # noqa: E501
        """Create a new access  # noqa: E501

        Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_access(access_dto, async=True)
        >>> result = thread.get()

        :param async bool
        :param Access access_dto: A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**. (required)
        :return: Access
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_access_with_http_info(access_dto, **kwargs)  # noqa: E501
        else:
            (data) = self.post_access_with_http_info(access_dto, **kwargs)  # noqa: E501
            return data

    def post_access_with_http_info(self, access_dto, **kwargs):  # noqa: E501
        """Create a new access  # noqa: E501

        Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_access_with_http_info(access_dto, async=True)
        >>> result = thread.get()

        :param async bool
        :param Access access_dto: A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**. (required)
        :return: Access
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['access_dto']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_access" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'access_dto' is set
        if ('access_dto' not in params or
                params['access_dto'] is None):
            raise ValueError("Missing the required parameter `access_dto` when calling `post_access`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'access_dto' in params:
            body_params = params['access_dto']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/accesses', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Access',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_access(self, access_id, access_dto, **kwargs):  # noqa: E501
        """Update access  # noqa: E501

        Update the access credentials in **accessFields**. If the access does not exist, the **accessId** does not match the **id** in **accessDto** or the **providerId** is not the same, the status code 404 is returned. If another access with the same login  data already exists, the status code 409 is returned.  The updated access is validated by setting up an account. The status code 200 does not imply that the credentials are correct. To check this the client should obtain access.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.put_access(access_id, access_dto, async=True)
        >>> result = thread.get()

        :param async bool
        :param str access_id: The **id** for the access to update. (required)
        :param Access access_dto: The Access object that contains the changed credentials in             **accessFields**. Other fields cannot be edited. (required)
        :return: Access
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.put_access_with_http_info(access_id, access_dto, **kwargs)  # noqa: E501
        else:
            (data) = self.put_access_with_http_info(access_id, access_dto, **kwargs)  # noqa: E501
            return data

    def put_access_with_http_info(self, access_id, access_dto, **kwargs):  # noqa: E501
        """Update access  # noqa: E501

        Update the access credentials in **accessFields**. If the access does not exist, the **accessId** does not match the **id** in **accessDto** or the **providerId** is not the same, the status code 404 is returned. If another access with the same login  data already exists, the status code 409 is returned.  The updated access is validated by setting up an account. The status code 200 does not imply that the credentials are correct. To check this the client should obtain access.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.put_access_with_http_info(access_id, access_dto, async=True)
        >>> result = thread.get()

        :param async bool
        :param str access_id: The **id** for the access to update. (required)
        :param Access access_dto: The Access object that contains the changed credentials in             **accessFields**. Other fields cannot be edited. (required)
        :return: Access
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['access_id', 'access_dto']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_access" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'access_id' is set
        if ('access_id' not in params or
                params['access_id'] is None):
            raise ValueError("Missing the required parameter `access_id` when calling `put_access`")  # noqa: E501
        # verify the required parameter 'access_dto' is set
        if ('access_dto' not in params or
                params['access_dto'] is None):
            raise ValueError("Missing the required parameter `access_dto` when calling `put_access`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'access_id' in params:
            path_params['accessId'] = params['access_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'access_dto' in params:
            body_params = params['access_dto']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/accesses/{accessId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Access',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
